#!/usr/bin/env python3
"""
An autogenerated testfile for python.
"""

import unittest
from io import StringIO
import os
import sys
import inspect
from unittest.mock import patch
from unittest import TextTestRunner
from examiner import ExamTestCase, ExamTestResult, tags
from examiner import import_module, find_path_to_assignment


FILE_DIR = os.path.dirname(os.path.realpath(__file__))
REPO_PATH = find_path_to_assignment(FILE_DIR)

if REPO_PATH not in sys.path:
    sys.path.insert(0, REPO_PATH)

# Path to file and basename of the file to import
em = import_module(REPO_PATH, 'emission_functions')
main = import_module(REPO_PATH, 'main')



class Test2EmissionFunctions(ExamTestCase):
    """
    Each assignment has 1 testcase with multiple asserts.
    The different asserts https://docs.python.org/3.6/library/unittest.html#test-cases
    """

    @classmethod
    def setUpClass(cls):
        """
        To find all relative files that are read or written to.
        """
        os.chdir(REPO_PATH)



    def check_print_contain(self, inp, correct, func, args=None):
        """
        One function for testing print input functions.
        """
        with patch("builtins.input", side_effect=inp):
            with patch("sys.stdout", new=StringIO()) as fake_out:
                if args is not None:
                    func(args)
                else:
                    func()
                str_data = fake_out.getvalue()
                for val in correct:
                    self.assertIn(val, str_data)


    @tags("12", "search_func")
    def test_search_country_func_missing(self):
        """
        Testar att funktionen `search_country(country)` lyfter ValueError om landet inte finns.
        Använder följande som argument till funktionen:
        {arguments}
        Förväntar att följande exception lyfts.
        {correct}
        Men inget lyftes!
        {student}
        """
        self.norepr = True
        self._argument = "Atlantis"
        with self.assertRaises(ValueError):
            em.search_country(self._argument)



    @tags("12", "search_func")
    def test_search_country_func_raises(self):
        """
        Testar att funktionen search_country innehåller raise konstruktionen.
        Förväntar att följande rad finns i din funktion:
        {correct}
        Din funktion innehåller följande:
        {student}
        """
        self.norepr = True
        self.assertIn("raise ValueError", inspect.getsource(em.search_country))



    @tags("12", "search_func")
    def test_search_country_func_multiple(self):
        """
        Testar att funktionen `search_country(country)` returnerar rätt värde när flera matchar och case-insensitive.
        Använder följande som argument till funktionen:
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Följande returnerades:
        {student}
        """
        self.norepr = True
        self._argument = "we"
        self.assertCountEqual(em.search_country(self._argument), ['Sweden', 'Western Sahara', 'Zimbabwe'])



    @tags("12", "search_func")
    def test_search_country_func_unique(self):
        """
        Testar att funktionen `search_country(country)` returnerar rätt värde när unique match.
        Använder följande som argument till funktionen:
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Följande returnerades:
        {student}
        """
        self.norepr = True
        self._argument = "Denmark"
        self.assertEqual(em.search_country(self._argument), ['Denmark'])




    @tags("change_func", "13")
    def test_get_country_year_data_missing_year(self):
        """
        Testar att funktionen `get_country_year_data(country, year)` lyfter error om året är fel.
        Använder följande som input:
        {arguments}
        Förväntar att följande fel lyfts:
        {correct}
        Men det felet lyftes inte!
        {student}
        """
        self.norepr = True
        self._multi_arguments = ["Dominica", "2021"]
        with self.assertRaises(ValueError):
            em.get_country_year_data_megaton(*self._multi_arguments)



    @tags("change_func", "13")
    def test_get_country_year_data_raises(self):
        """
        Testar att funktionen get_country_year_data_megaton innehåller raise konstruktionen.
        Förväntar att följande rad finns i din funktion:
        {correct}
        Din funktion innehåller följande:
        {student}
        """
        self.norepr = True
        self.assertIn("raise ValueError", inspect.getsource(em.get_country_year_data_megaton))



    @tags("change_func", "13")
    def test_get_country_year_data(self):
        """
        Testar att funktionen `get_country_year_data(country, year)` returnerar rätt data för land och år.
        Använder följande som input:
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Följande returnerades:
        {student}
        """
        self.norepr = True
        self._multi_arguments = ["Dominica", "2017"]
        self.assertEqual(em.get_country_year_data_megaton(*self._multi_arguments), 122000.0)



    @tags("change_func", "13")
    def test_get_country_change_years(self):
        """
        Testar att funktionen `get_country_change_for_years(country, year1, year2)` returnerar rätt data för land och år.
        Använder följande som input:
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Följande returnerades:
        {student}
        """
        self.norepr = True
        self._multi_arguments = ["China", "1990", "2017"]
        self.assertEqual(em.get_country_change_for_years(*self._multi_arguments), 353.78)



    @tags("change_func", "13")
    def test_get_country_change_years_error(self):
        """
        Testar att funktionen `get_country_change_for_years(country, year1, year2)` får error från `get_country_year_data_megaton()` när felaktigt år används.
        Använder följande som input:
        {arguments}
        Förväntar att följande error lyfts:
        {correct}
        Men det lyftes inte!
        {student}
        """
        self.norepr = True
        self._multi_arguments = ["China", "1000", "2017"]
        with self.assertRaises(ValueError):
            em.get_country_change_for_years(*self._multi_arguments)



    @tags("14", "func")
    def test_get_country_data_missing_population(self):
        """
        Testar att funktionen `get_country_data(country_name)` returnerar rätt när ett land saknar population.
        Använder följande som input:
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Följande returnerades:
        {student}
        """
        self.norepr = True
        self._argument = "Greenland"
        self.assertEqual(
            em.get_country_data(self._argument),
            {
                'name': 'Greenland',
                '1990': {'emission': 3000.0, 'population': None},
                '2005': {'emission': 631000.0, 'population': None},
                '2017': {'emission': 518000.0, 'population': None},
                'emission_change': (20933.33, -17.91)
            }
        )



    @tags("14", "data_func")
    def test_get_country_data(self):
        """
        Testar att funktionen `get_country_data(country_name)` returnerar rätt data.
        Använder följande som input:
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Följande returnerades:
        {student}
        """
        self.norepr = True
        self._argument = "United States of America"
        self.assertEqual(
            em.get_country_data(self._argument),
            {
                'name': 'United States of America',
                '1990': {'emission': 5085897000.0, 'population': 252120309},
                '2005': {'emission': 5971571000.0, 'population': 294993509},
                '2017': {'emission': 5107393000.0, 'population': 325084758},
                'emission_change': (17.41, -14.47)
            }
        )




    @tags("14", "data_func")
    def test_print_country_data_missing_pop(self):
        """
        Testar att funktionen `print_country_data(data)` skriver ut rätt data. Där population saknas
        Använder följande som input:
        {arguments}
        Förväntar att följande finns med i utskriften:
        {correct}
        Följande skrevs ut:
        {student}
        """
        self.norepr = True
        self._argument = {
            'name': 'Palau',
            '1990': {'emission': 2155000.0, 'population': None},
            '2005': {'emission': 1734000.0, 'population': None},
            '2017': {'emission': 1411000.0, 'population': None},
            'emission_change': (-0.2, -0.19)
        }
        answer = [
            "Palau",
            "1990: 2155000.0",
            "2005: 1734000.0",
            "2017: 1411000.0",
            "1990-2005: -0.2%",
            "2005-2017: -0.19%",
            "Missing population data!",
        ]
        self.check_print_contain("", answer, em.print_country_data, self._argument)



if __name__ == '__main__':
    runner = TextTestRunner(resultclass=ExamTestResult, verbosity=2)
    unittest.main(testRunner=runner, exit=False)
